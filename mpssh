#!/usr/bin/env python3

import json
import threading
import subprocess
from datetime import datetime
from colorama import Fore, Style, init
import argparse
import sys

init()

def now():
  return datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]

def ssh_connect_and_run_command(
    host, command, thread_color, raw=False, timeout=30
):
    try:
        ssh_command = f"ssh -o ConnectTimeout={timeout} {host} '{command}'"
        print(ssh_command)
        process = subprocess.Popen(
            ssh_command,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        if not raw:
          print(f"{Fore.GREEN}[{now()}] Running command on {host}...{Style.RESET_ALL}")

        while True:
            assert process.stdout is not None, "stdout is None"
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                if raw:
                  print(f"{host}: {output.strip()}")
                else:
                  print(f"{thread_color}[{now()}] {host}: {output.strip()}{Style.RESET_ALL}")
        assert process.stderr is not None, "stderr is None"
        error_output = process.stderr.read()
        if error_output:
            if raw:
              print(f"{host}: {error_output.strip()}")
            else:
              print(f"{thread_color}[{now()}] {host}:{Fore.RED} {error_output.strip()}{Style.RESET_ALL}")
        if process.returncode != 0:
          if raw:
            print(f"{host}: Command failed with return code {process.returncode}")
          else:
            print(f"{thread_color}[{now()}] {host}: {Fore.RED}Command failed with return code {process.returncode}{Style.RESET_ALL}")
          return process.returncode
    except Exception as e:
        if not raw:
          print(f"{Fore.RED}[{now()}] Failed to connect to {host}: {Style.RESET_ALL}")
        else:
          print(f"Failed to connect to {host}")
        return -1
    return 0

def main():
    parser = argparse.ArgumentParser(
        description='Run a command on multiple hosts via SSH.'
    )
    parser.add_argument(
        '--raw',
        action='store_true',
        help='Print raw output without any formatting'
    )
    parser.add_argument(
        '--timeout',
        type=int,
        default=3,
        help='SSH connection timeout in seconds'
    )
    parser.add_argument(
        'json_file',
        type=str,
        help='The JSON file containing the list of hosts'
    )
    parser.add_argument('hostgroup', type=str, help='The hostgroup to run the command on')
    parser.add_argument('command', nargs=argparse.REMAINDER , help='The command to run on each host')
    args = parser.parse_args()

    with open(args.json_file, 'r') as file:
        data = json.load(file)

    hostgroup = data.get(args.hostgroup)
    if not hostgroup:
        if not args.raw:
          print(f"{Fore.RED}Hostgroup '{args.hostgroup}' not found in JSON file{Style.RESET_ALL}")
        else:
          print(f"Hostgroup '{args.hostgroup}' not found in JSON file")
        return 1

    threads = []
    results = {}
    thread_colors = [Fore.GREEN, Fore.YELLOW, Fore.BLUE, Fore.MAGENTA, Fore.CYAN]
    current_available_colors = thread_colors.copy()

    for host in hostgroup:
        if not current_available_colors:
            current_available_colors = thread_colors.copy()
        thread_color = current_available_colors.pop()
        
        # Create a thread with a wrapper function that stores the result
        def thread_wrapper(host=host, thread_color=thread_color):
            results[host] = ssh_connect_and_run_command(
                host,
                ' '.join(args.command),
                thread_color,
                args.raw,
                args.timeout
            )
        
        thread = threading.Thread(target=thread_wrapper)
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()

    # Return 1 if any command failed, 0 otherwise
    return 1 if any(code != 0 for code in results.values()) else 0

if __name__ == "__main__":
    sys.exit(main())
