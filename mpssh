#!/usr/bin/env python3

import json
import threading
import subprocess
from datetime import datetime
from colorama import Fore, Style, init
import argparse
import sys

init()

def now():
  return datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]

def ssh_connect_and_run_command(
    host, command, thread_color, raw=False, spicy=False, timeout=30
):
    try:
        ssh_command = f"ssh -o ConnectTimeout={timeout} {host} '{command}'"
        print(ssh_command)
        process = subprocess.Popen(
            ssh_command,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        if not raw:
          print(f"{Fore.GREEN}[{now()}] Running command on {host}...{Style.RESET_ALL}")

        while True:
            assert process.stdout is not None, "stdout is None"
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                if raw:
                  print(f"{host}: {output.strip()}")
                else:
                  print(f"{thread_color}[{now()}] {host}: {output.strip()}{Style.RESET_ALL}")
        assert process.stderr is not None, "stderr is None"
        error_output = process.stderr.read()
        if error_output:
            if raw:
              print(f"{host}: {error_output.strip()}")
            else:
              print(f"{thread_color}[{now()}] {host}:{Fore.RED} {error_output.strip()}{Style.RESET_ALL}")
        if process.returncode != 0:
          if spicy:
            raise Exception(f"Command failed on {host}")
          if raw:
            print(f"{host}: Command failed with return code {process.returncode}")
          else:
            print(f"{thread_color}[{now()}] {host}: {Fore.RED}Command failed with return code {process.returncode}{Style.RESET_ALL}")
    except Exception as e:
        if not raw:
          print(f"{Fore.RED}[{now()}] Failed to connect to {host}: {Style.RESET_ALL}")
        else:
          print(f"Failed to connect to {host}")
        if spicy:  # Only raise if spicy mode is enabled
            raise

def main():
    parser = argparse.ArgumentParser(
        description='Run a command on multiple hosts via SSH.'
    )
    parser.add_argument(
        '--raw',
        action='store_true',
        help='Print raw output without any formatting'
    )
    parser.add_argument(
        '--spicy',
        action='store_true',
        help='Exit with error if any command fails'
    )
    parser.add_argument(
        '--timeout',
        type=int,
        default=3,
        help='SSH connection timeout in seconds'
    )
    parser.add_argument(
        'json_file',
        type=str,
        help='The JSON file containing the list of hosts'
    )
    parser.add_argument('hostgroup', type=str, help='The hostgroup to run the command on')
    parser.add_argument('command', nargs=argparse.REMAINDER , help='The command to run on each host')
    args = parser.parse_args()

    with open(args.json_file, 'r') as file:
        data = json.load(file)

    hostgroup = data.get(args.hostgroup)
    if not hostgroup:
        if not args.raw:
          print(f"{Fore.RED}Hostgroup '{args.hostgroup}' not found in JSON file{Style.RESET_ALL}")
        else:
          print(f"Hostgroup '{args.hostgroup}' not found in JSON file")
        return 1


    threads = []
    thread_colors = [Fore.GREEN, Fore.YELLOW, Fore.BLUE, Fore.MAGENTA, Fore.CYAN]
    current_available_colors = thread_colors.copy()
    happy = True
    for host in hostgroup:
        try:
          if not current_available_colors:
              current_available_colors = thread_colors.copy()
          # Pick a random colour for each thread, to make it easier to distinguish the output
          # Don't repeat if possible
          thread_color = current_available_colors.pop()
          thread = threading.Thread(
              target=ssh_connect_and_run_command,
              args=(
                  host,
                  ' '.join(args.command),
                  thread_color,
                  args.raw,
                  args.spicy,
                  args.timeout
              )
          )
          threads.append(thread)
          thread.start()
        except Exception:
          happy = False

    for thread in threads:
        try:
            thread.join()
        except Exception:
            happy = False
    if not happy:
        return 1

if __name__ == "__main__":
    sys.exit(main())
